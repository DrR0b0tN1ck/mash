import filecmp
import hashlib
import os
import subprocess
import shutil
import difflib
import glob
import time

class Frame:

  def import_and_mangle(self, mash, fr):
    fr = os.path.join(mash.original_directory,fr)
    to = self.import_file(mash, fr)
    return to

  def resolve_chunk(self, key):
    try:
      x = self.chunks[key]
      return x
    except KeyError:
      try:
        return self.parent.resolve_chunk(key)
      except AttributeError:
        raise Exception("Chunk '%s' not found." % key)

  def execute(self, mash):

    # For things like "@abc/xyz", import that file, and replace with "xyz".
    self.text = re.sub(r'@@([^\n},\']*)', lambda m: self.import_and_mangle(mash, m.group(1)), self.text)

    # Loop through the commands we have.
    while command_list:

      # For things like "@abc/def", import that file, and replace with "def".
      command = re.sub(r'@@([^\n},]*)', lambda m: self.import_and_mangle(mash, m.group(1)), command)

      # Replace things like $1 with anonymous names based on hashing the text.
      command = re.sub(r'\$(\d+)', lambda m: self.make_name(m.group(1)), command)

      # Replace things like &abc with the corresponding chunk.
      def expand_chunk(m):
        x = self.resolve_chunk(m.group(1))
        return x
      command = re.sub(r'\&([A-Za-z0-9]+)', expand_chunk, command)
      self.show(command)
      
      # print: Print literal text into the parent frame at this location.
      match = re.search(r"^print +(.*)", command)
      if match:
        output = match.group(1)
        self.parent.append_text(output)
        continue

      # Read a file (or files) and append their contents to the text of this
      # frame.
      match = re.search(r"^read +(.*)", command)
      if match:
        for filename in glob.glob(match.group(1)):
          self.show("  " + filename)
          f = open(filename, 'r')
          self.append_text(f.read())
          f.close()
        continue

      # Include another mash file.
      match = re.search(r"^include +(.*)", command)
      if match:
        file_to_include = match.group(1)
        include_text = open(os.path.join(mash.original_directory, file_to_include), 'r').read()
        mash.mash_string(include_text, self)
        self.parent.append_text(self.text)
        self.parent.macros.update(self.macros)
        self.parent.chunks.update(self.chunks)
        continue

      # Process our text as mash code.  Not needed for code literally in the
      # source file, but if some previous commands have turned the text into
      # mash code...
      match = re.search(r"^mash", command)
      if match:
        mash.mash_string(self.text, self)
        continue


      # Import a file from the input directory into the build directory.
      match = re.search(r"^import +(.*)", command)
      if match:
        pattern = match.group(1)
        globs = glob.glob(os.path.join(mash.original_directory,pattern))
        if not globs:
          raise Exception("Trying to import %s, but no files match." % pattern)

        for fr in globs:
          to = self.import_file(mash, fr)

        continue

      # store: Scan the text for named chunks, using the given pattern.  Store
      # them for later in our chunks dictionary.
      match = re.search(r"^store +(.*)", command)
      if match:
        pattern = match.group(1)

        number_of_chunks_before = len(self.chunks)

        def store_chunk(m):
          key = m.group(1)
          try:
            value = m.group(2)
          except IndexError:
            raise Exception("Invalid store pattern '%s'.  Needs a second group." % pattern)
          self.show("  chunk " + key)
          self.chunks[key] = value

        re.sub(pattern, store_chunk, self.text, flags=re.DOTALL)

        ## number_of_chunks_after = len(self.chunks)
        ## difference = number_of_chunks_after - number_of_chunks_before

        ## if difference == 0:
        ##   raise Exception("No new chunks found for pattern '%s' in this text:\n%s" % (pattern, self.text))

        continue

      # chunk: Append a named chunk to the text.
      match = re.search(r"^chunk +(.*)", command)
      if match:
        key = match.group(1)
        self.append_text(self.resolve_chunk(key))
        continue

      # quit: Ignore the rest of the commands in this frame.
      match = re.search(r"^quit", command)
      if match:
        break

      # Last change: Is it a macro to expand?
      match = re.search(r"([a-zA-Z0-9_-]+) *(.*)", command)
      if match:
        macro_name = match.group(1)
        macro_args = self.split_arguments(match.group(2))
        expansion = self.resolve_macro(macro_name, macro_args)
        if expansion:
          self.show("  expanding macro to:" + ";".join(expansion))
          command_list = self.resolve_macro(macro_name, macro_args) + command_list
          continue
        else:
          # No definition for this macro.
          pass

      # Couldn't make any sense of this command.
      raise Exception("Unknown command: %s" % command)
  


    # All done executing commands.  Last step: If we're dirty, then our parent
    # should be dirty too.
    if self.dirty:
      self.parent.dirty = True
    
    # Done!
    return

  def split_commands(self, commands):
    # This is only a partial solution, because it might require semicolons to
    # be escaped several times if there macros involved.
    return map(lambda x: re.sub(r'__SEMICOLON__', ';', x), re.sub(r'\\;', '__SEMICOLON__', commands).split(';'))

  def split_arguments(self, commands):
    return map(lambda x: re.sub(r'__COMMA__', ',', x), re.sub(r'\\,', '__COMMA__', commands).split(','))
  
  def __repr__(self):
    return "Frame(%s,%s)" % (self.commands.__repr__(), self.text.__repr__())



class Mash:

  def mash_string(self, text, top_frame):
    while text:
      # Match an opening delimiter?
      match = re.search(r"^\[\[\[(.*)\n(\s*)", text)
      if match:
        commands = match.group(1)
        indent = match.group(2)

        # Remove the part that matched from the input text.
        text = text[len(match.group(0)):]

        # Is this a one-liner or a multi-liner?
        match2 = re.search(r"^(.*?)\]\]\](.*)", commands)
        if match2:
          # A one line frame.  Create the frame and execute it right away.
          # Then put everything we've matched after that (including the newline
          # and indent matched in the first re above) back in at the front of
          # the input text.
          commands = match2.group(1)
          Frame(current_frame, commands, len(indent), current_frame.chunks['this']).execute(self)
          text = match2.group(2) + '\n' + indent + text
        else:
          # A multi-line frame.  Create a new frame as the child of the current
          # one.  We'll add the text in future iterations of this loop, and
          # execute when we see the closing delimiter.
          current_frame = Frame(current_frame, commands, len(indent), current_frame.chunks['this'])
        
        continue
          


  def engage(self):
    parser.add_argument('--diff', dest='diff', help='show differences in saved files', action='store_true')
    parser.add_argument('--keep_directory', '-k', dest='keep_directory', help='directory for kept files', default='.')
    parser.add_argument('--clean', '-c', dest='clean', action='store_true')

    if self.args.clean:
      if os.path.exists(self.args.build_directory):
        shutil.rmtree(self.args.build_directory)
      if self.args.input_filename is None:
        return


    


