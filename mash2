#!/usr/bin/env python3

# -- mash --
#
# This is a tool that allows text in various languages to be stored together
# in a single input file. along with instructions for manipulating, mutating,
# and storing that text.
#
# Q. Why?
#
# A1. Allows me to avoid naming things that appear only quickly in passing.
# A2. Allows me to divide things into files based on content, rather than
#     language.
# A3. Can keep content and build instructions in the same place.
#
# History:
#   2016-11-17: Started as a revision of some older, presentation-specific scripts.
#   2016-12-12: First working version.
#   2017-02-20: Various language additions, mostly for build commands.
#   2017-04-20: More language expansions.  Better error handling.
#   2017-07-11: Betting handling of semicolons in commands.
#   2017-12-05: Better error messages.
#   2018-04-06: @@ syntax for quick importing
#   2018-07-26: Better handling of commas in commands.
#   2018-08-17: & syntax for inserting chunks.
#   2019-04-02: Starting major rewrite, replacing custom language with Python.

import argparse
import sys
import re
import os
import shutil
import subprocess
import time

class Frame:
  def __init__(self, _parent, file_name):
    # Remember our parent frame, or None if we're the root.
    self.parent = _parent

    # Remember what file we come from.
    self.file_name = file_name

    # The full contents of this frame, including commands and text, which will
    # be filled in as we go.
    self.contents = ""

  def execute(self, mash):
    mash.frame_count += 1

    # Do we have a command separator?
    match = re.match("(.*)\|\|\|(.*)", self.contents, re.DOTALL)
    if match:
      # Yes.  Everything before are the commands; everything after is the text.
      self.commands = match.group(1)
      self.text = match.group(2)
    else:
      # No.  All of it is commands.
      self.commands = self.contents
      self.text = ''

    # Fix the indentation of the commands.  This allows us to
    # write python code that is _all_ indented, without annoying
    # the interpreter.
    self.commands = unindent(self.commands)

    #print("commands:\n", self.commands)
    #print("text:\n", self.text)

    # Check for and execute any special commands.
    # 1. include <fname>: Search the path for a file with the given name.
    # Execute it as mash code.
    def resolve_include(match):
      fname = match.group(1)
      if fname in mash.included:
        return
      for directory in sys.path:
        x = os.path.join(directory, fname)
        if os.path.exists(x):
          print(x)
          mash.included.add(fname)
          mash.mash_string(open(x, 'r').read(), Frame(self, x))
          return
      raise Exception("Trying to include %s, but could not find it in any of these places:\n%s" % (fname, '\n'.join(sys.path)))

    self.commands = re.sub('(?m)^\s*include (.*)$', resolve_include, self.commands)

    # Actually execute the commands.
    mash.vars['_'] = self
    if "before_frame_hook" in mash.vars:
      code = compile("before_frame_hook()", self.file_name, 'exec')
      exec(code, mash.vars, mash.vars)
    code = compile(self.commands, self.file_name, 'exec')
    exec(code, mash.vars, mash.vars)
    if "after_frame_hook" in mash.vars:
      code = compile("after_frame_hook()", self.file_name, 'exec')
      exec(code, mash.vars, mash.vars)

def unindent(s):
  # Find the prefix that we want to remove.  It is the sequence
  # of tabs or spaces that preceeds the first real character.
  match = re.search(r'([ \t]*)[^ \t\n]', s)

  # If we found a prefix, remove it from the start of every line.
  if match:
    prefix = match.group(1)
    s = re.sub('\n' + prefix, '\n', s)
  return s

class Mash:
  def mash_string(self, text, top_frame):
    # The current frame for whatever we're parsing now.  The top
    # one has no parent.
    current_frame = top_frame

    # Walk through the text, looking for child frames, consuming
    # the text from the local variable 'text' as we go.
    while text:
      # Do we have an opening delimiter next?
      match = re.search(r"^\[\[\[", text)
      if match:
        # Yes, this is the start of a new frame.  Create it as the
        # child of the current one.  We'll add the text in future
        # iterations of this loop, and execute it when we see the
        # closing delimiter.
        current_frame = Frame(current_frame, current_frame.file_name)
        text = text[3:]
      
      # Do we have a closing delimiter next?
      match = re.search(r"^\]\]\]", text)
      if match:
        current_frame.execute(self)
        if current_frame.parent is None:
          raise Exception("Found a closing delimiter (]]]) at the top level.")
        current_frame = current_frame.parent
        text = text[3:]
        continue

      # Not seeing opening nor closing delimiters.  Grab as much ordinary text as
      # we can.  At least one character, until we see [ or ] again.
      match = re.search(r"^(.[^\[\]]*)", text, re.DOTALL)
      current_frame.contents += match.group(0)
      eaten = match.group(1)
      text = text[len(eaten):]
    

  def fix_path(self, path):
    """ Make sure the given path is absolute, and that it exists."""
    if not os.path.isabs(path):
      path = os.path.join(self.original_directory, path)

    if not os.path.exists(path):
      os.makedirs(path)
    return path
    
  def engage(self):
    """ This is the 'main' function."""
    start_time = time.time()

    parser = argparse.ArgumentParser()
    parser.add_argument(dest='input_filename', help='input filename', nargs='+')
    parser.add_argument('--debug', '-d', dest='debug', help='on error, show stack trace', action='store_true')
    parser.add_argument('--clean', '-c', dest='clean', action='store_true')
    self.args = parser.parse_args()

    if self.args.clean:
      if os.path.exists(".mash"):
        shutil.rmtree(".mash")
      if os.path.exists(".mash-prev"):
        shutil.rmtree(".mash-prev")
      if self.args.input_filename is None:
        return

    if self.args.input_filename is None:
      parser.print_help()
      sys.exit(1)
    
    original_directory = os.getcwd()
    for input_filename in self.args.input_filename:
      os.chdir(original_directory)
      self.frame_count = 1
      self.included = set()

      self.vars = dict()

      text = open(input_filename, 'r').read()
      
      if self.args.debug:
        self.mash_string(text, Frame(None, input_filename))
      else:
        try:
          self.mash_string(text, Frame(None, input_filename))
        except Exception as e:
          print("Error:", e)
          sys.exit(1)

    end_time = time.time()
    print("%d frames; %0.1f seconds" % (self.frame_count, end_time - start_time))

if __name__ == '__main__':
  Mash().engage()

  
