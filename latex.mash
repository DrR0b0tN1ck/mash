[[[ include mashlib.mash ]]]

[[[
  latex_mode = 'pdflatex'
    # Which LaTeX compiler should we use?  Choices are:
    # -- pdflatex
    # -- latex
    # -- xelatex
    # This affects both the specific compiler used and the graphics formats.

  def latex(name, compiler=None, ignore_deps=list(), keep_pdf=True, callback=None, max_compiles=None):
    # Complain in old documents.
    if compiler is not None:
      raise Exception('Compiler argument to latex() is no longer supported.  Set latex_mode variable instead.')

    # Write the document.
    save(name + ".tex") 

    # Build a list of dependencies.
    
    # Regular expressions whose matches give us dependencies.  Each one should
    # have a group named 'dep' that gives the name of the depended-upon file.
    dep_patterns = [
      r'\\includegraphics(\[.*?\])?{(?P<dep>[^}]*)}',
      r'\\lstinputlisting(\[.*?\])?{(?P<dep>[^}]*)}',
      r'\\input{(?P<dep>[^}]*)}',
      r'\\includepdf{(?P<dep>[^}]*)}',
      r'% dep (?P<dep>[^\n]*)',
      r'\\bibliography{(?P<dep>[^\n]*)}'
    ]

    deps = [name + ".tex"]
    for pattern in dep_patterns:
      for match in re.finditer(pattern, _.text, re.DOTALL):
        deps.append(match.group('dep'))

    deps = [item for item in deps if item not in ignore_deps]

    if not recall(name+".pdf", *deps):
      # Run the compiler over and over until the log stops changing.
      last_log = ''
      bibtex_done = False
      makeindex_done = False
      callback_done = False
      compiles = 0
      while True:
        try:
          shell(latex_mode + " -interaction=batchmode -file-line-error -halt-on-error %s" % name)
          compiles+=1
        except subprocess.CalledProcessError as e:
          e.stderr = open(name + '.log', 'r').read()
          raise e
        log = open(name+'.log', 'r').read()
        if not callback_done and callable(callback):
          callback()
        if not bibtex_done:
          aux = open(name+'.aux', 'r').read()
          if re.search(r'\\citation', aux):
            shell("bibtex -terse %s" % name)
            bibtex_done = True
        if not makeindex_done and os.path.isfile(name+".idx"):
          shell("makeindex %s.idx" % name)
          makeindex_done = True
        if max_compiles and compiles >= max_compiles: break
          
        if log == last_log: break
        last_log = log

      if latex_mode == 'latex':
        shell('dvipdf %s.dvi' % name)

    if keep_pdf:
      keep(name+".pdf")

  def dot(name=None, via_xfig=False, xfig_direct=True, args=''):
    # If we don't have a name, make one up.
    if not name:
      name = anon()

    # Figure out which format we should convert to.
    if latex_mode == 'latex':
      fmt = 'eps'
    else:
      fmt = 'pdf'

    name_dot = ext(name, 'dot')
    name_fig = ext(name, 'fig')
    name_fmt = ext(name, fmt)
    name_eps = ext(name, 'eps')
    save(name_dot)
    if via_xfig:
      if not recall(name_fig, name_dot):
        shell("dot -Tfig %s > %s" % (name_dot, name_fig))
      xfig(name_fig, args, direct=xfig_direct)
    else:
      if not recall(name_fmt, name_dot):
        shell("dot -T%s %s > %s" % (fmt, name_dot, name_fmt))
      push("\\includegraphics[%s]{%s}" % (args, name_fmt))

  def xfig(fname_fig, args='', direct=True):
    """
    Insert an xfig diagram.
    """

    # TODO: A few useful things like layers are implemented in the
    # jokane-talk.mash version of this function.

    fig_source = open(fname_fig, 'r').read()

    # Find any referenes to embedded images.
    deps = list()
    for match in re.finditer(r'^(2 5 ([0-9\.-]*\s+){13}[0-9\.-]*$\s*\d\s*(.*))', fig_source, re.MULTILINE):
      pic = match.group(3)
      imprt(pic)
      deps.append(pic)

    # Figure out which format we should convert to.
    if latex_mode == 'latex':
      fmt = 'eps'
      shfmt = 'ps'
    else:
      fmt = 'pdf'
      shfmt = 'pdf'
    fname_fmt = ext(fname_fig, fmt)
    fname_tex = ext(fname_fig, 'tex')
  
    if direct:
      # Convert to the two part pdf/latex or ps/latex form.
      if args != '':
        raise Exception(r"Don't know what to do with args in xfig() with direct=True.  Maybe wrap in a \resizebox instead?")

      if not recall(fname_fmt, fname_fig, *deps):
        shell("fig2dev -L %stex -O %s > %s" % (shfmt, fname_fig, fname_fmt))
      if not recall(fname_tex, fname_fig, *deps):
        shell("fig2dev -L %stex_t -p %s %s > %s" % (shfmt, fname_fmt, fname_fig, fname_tex))
      push(r"\input{%s}" % (fname_tex, ))
    else:
      # Convert directly to an external format that can be inserted with
      # \includegraphics.  Does not typeset labels with LaTeX.
      if not recall(fname_fmt, fname_fig, *deps):
        shell("fig2dev -L %s %s %s" % (fmt, fname_fig, fname_fmt))
      push("\includegraphics[%s]{%s}" % (args, fname_fmt))

  def image(name_orig, args=''):
    if latex_mode == 'latex':
      supported_fmts = ['eps']
      target_fmt = 'eps'
    else:
      supported_fmts = ['pdf', 'png', 'jpg']
      target_fmt = 'pdf'

    (base, fmt) = os.path.splitext(name_orig)

    # If the image we have is not in a supported format, convert it.
    name_tgt = ext(name_orig, target_fmt)
    if fmt not in supported_fmts and not recall(name_tgt, name_orig):
      shell("convert %s %s" % (name_orig, name_tgt))
    
    # Insert the image into the document.
    push("\\includegraphics[%s]{%s}" % (args, name_tgt))

]]]
