#!/usr/bin/env python


import argparse
import sys
import re
import os
import subprocess
import shutil

def announce_file_in(fname):
  print >>sys.stderr, "-->", fname

def announce_file_out(fname):
  print >>sys.stderr, "<---", fname

class Frame:
  def __init__(self, _commands, _text=""):
    self.commands = _commands 
    self.text = _text

  def append_text(self, new_text):
    self.text += new_text

  def execute(self, mash, parent):
    print "execute:"
    print "  self:", self
    print "  parent:", parent
    for command in self.commands.split(';'):
      command = command.strip()
      print "  command:", command

      # Save the text to a file.
      match = re.search(r"^save (.*)", command)
      if match:
        target = match.group(1)
        print "Saving to ", target
        f = open(target, 'w')
        print >>f, self.text
        f.close()
        continue
      
      # Print a literal into the parent frame.
      match = re.search(r"^print (.*)", command)
      if match:
        output = match.group(1)
        parent.append_text(output)
        continue

      # Execute a command
      match = re.search(r"^exec (.*)", command)
      if match:
        shell_command = match.group(1)
        os.system(shell_command)
        continue

      # Keep a file, by copying it to the input directory.
      match = re.search(r"^keep (.*)", command)
      if match:
        file_to_keep = match.group(1)
        shutil.copy(file_to_keep, mash.original_directory)
        continue

      # Other commands that might make sense:
      # - append
      # - cat (insert contents of a file)
      # - read (append/replace the contents of a file to the text of the current frame)
      
      # ?
      print command
      raise
  
  def __repr__(self):
    return "Frame(%s,%s)" % (self.commands.__repr__(), self.text.__repr__())

class RootFrame:
# Objects of this class act sufficiently like Frame objects to simplify the
# code below a bit, because they ensure that the stack is never empty, and that
# every real frame has a parent.
  def append_text(self, new_text):
    print "root-level text:", new_text


class Mash:
  def engage(self):
    parser = argparse.ArgumentParser()
    parser.add_argument(dest='input_filename', help='input filename')
    parser.add_argument('--debug', '-d', dest='debug', help='show debugging information', action='store_true')
    parser.add_argument('--output_directory', '-o', dest='output_directory', help='directory for output files', default='.mash_cache')
    self.args = parser.parse_args()

    if not os.path.exists(self.args.output_directory):
      announce_file_out(self.args.output_directory) 
      os.makedirs(self.args.output_directory)

    self.original_directory = os.getcwd()

    announce_file_in(self.args.input_filename)
    text = open(self.args.input_filename, 'r').read()

    os.chdir(self.args.output_directory)
    self.mash_string(text)

  def mash_string(self, text):
    # Find the next open or close tag.
    # match = re.search(r"(\[\[\[)|(\]\]\])", text)


    stack = [ RootFrame() ]
      # A stack of the various frames we're parsing at the moment.
      # Each element is a pair:
      # - The command string
      # - The text itself.
    
    while text:
      # Match an opening delimiter?
      match = re.search(r"^\[\[\[(.*)", text)
      if match:
        commands = match.group(1)
        stack.append(Frame(commands))
        text = text[len(match.group(0)):]
        continue

      # Match a closing delimiter?
      match = re.search(r"^\]\]\]", text)
      if match:
        completed_frame = stack.pop()
        completed_frame.execute(self, stack[-1])
        text = text[3:]
        continue
      
      # Not seeing opening or closing delimiters.  Grab as much ordinary text as
      # we can.  At least one character, until we see [ or ] again.
      match = re.search(r"^(.[^\[\]]*)", text, re.DOTALL)
      stack[-1].append_text(match.group(0))
      eaten = match.group(1)
      text = text[len(eaten):]


if __name__ == '__main__':
  Mash().engage()

  
