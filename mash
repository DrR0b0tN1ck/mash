#!/usr/bin/env python


import argparse
import sys
import re

def announce_file_in(fname):
  print >>sys.stderr, "-->", fname

def announce_file_out(fname):
  print >>sys.stderr, "<---", fname


def mash_string(text):
  # Find the next open or close tag.
  match = re.search(r"(\[\[\[)|(\]\]\])", text)

  top_level = '(top level)'
  stack = [ top_level ]
  docs = { top_level : '' }
  
  while text:
    match = re.search(r"^\[\[\[(.*)", text)
    if match:
      filename = match.group(1)
      print "open:", filename
      stack.append(filename)
      docs[filename] = ""
      print "stack:", stack
      text = text[len(match.group(0)):]
      continue

    match = re.search(r"^\]\]\]", text)
    if match:
      print "close"
      stack.pop()
      print "stack:", stack
      text = text[3:]
      continue

    match = re.search(r"^\[\[\[(.*)", text)
    if match:
      print "open:", match.groups()
    
    match = re.search(r"^(.[^\[\]]*)", text, re.DOTALL)

    print "plain text:", match.groups(0)
    eaten = match.group(1)
    docs[stack[-1]] += eaten
    print (eaten,)
    text = text[len(eaten):]

  for (doc, text) in docs.iteritems():
    if doc == top_level: continue
    print doc
    print text
    f = open(doc, 'w')
    print >>f, text
    f.close()

if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument(dest='input_filename', help='input filename')
  parser.add_argument('--debug', '-d', dest='debug', help='show debugging information', action='store_true')
  args = parser.parse_args()

  announce_file_in(args.input_filename)
  text = open(args.input_filename, 'r').read()
  mash_string(text)

  
