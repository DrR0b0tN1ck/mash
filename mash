#!/usr/bin/env python


import argparse
import hashlib
import sys
import re
import os
import subprocess
import shutil

def announce_file_in(fname):
  print >>sys.stderr, "-->", fname

def announce_file_out(fname):
  print >>sys.stderr, "<--", fname

class Frame:
  def __init__(self, _commands, _text=""):
    self.commands = _commands 
    self.text = _text
    self.text_hash = None

  def append_text(self, new_text):
    self.text += new_text

  def make_name(self, number):
    print "making name for $%s" % number
    if self.text_hash is None:
      self.text_hash = hashlib.sha1(self.text + number).hexdigest()[:7]
    return self.text_hash + number

  def execute(self, mash, parent):
    print "[[[%s]]]" % self.commands

    print "  before:", self.commands
    self.commands = re.sub(r'\$(\d+)', lambda m: self.make_name(m.group(1)), self.commands)
    print "  after:", self.commands

    for command in self.commands.split(';'):
      command = command.strip()

      # Save the text to a file.
      match = re.search(r"^save (.*)", command)
      if match:
        target = match.group(1)
        announce_file_out(target)
        f = open(target, 'w')
        print >>f, self.text
        f.close()
        continue

      # Save the text to a file.
      match = re.search(r"^append (.*)", command)
      if match:
        target = match.group(1)
        print "Appending to ", target
        f = open(target, 'a')
        print >>f, self.text
        f.close()
        continue
      
      # Print a literal into the parent frame.
      match = re.search(r"^print (.*)", command)
      if match:
        output = match.group(1)
        parent.append_text(output)
        continue

      # Execute a command
      match = re.search(r"^exec (.*)", command)
      if match:
        shell_command = match.group(1)
        os.system(shell_command)
        continue

      # Keep a file, by copying it to the input directory.
      match = re.search(r"^keep (.*)", command)
      if match:
        file_to_keep = match.group(1)
        shutil.copy(file_to_keep, mash.original_directory)
        continue

      # Other commands that might make sense:
      # - append
      # - cat (insert contents of a file)
      # - read (append/replace the contents of a file to the text of the current frame)
      # - promote (append the text of the current frame to the text of the parent frame)
      
      # ?
      print command
      raise
  
  def __repr__(self):
    return "Frame(%s,%s)" % (self.commands.__repr__(), self.text.__repr__())

class RootFrame:
# Objects of this class act sufficiently like Frame objects to simplify the
# code below a bit, because they ensure that the stack is never empty, and that
# every real frame has a parent.
  def append_text(self, new_text):
    print "root-level text:", new_text


class Mash:
  def engage(self):
    parser = argparse.ArgumentParser()
    parser.add_argument(dest='input_filename', help='input filename')
    parser.add_argument('--debug', '-d', dest='debug', help='show debugging information', action='store_true')
    parser.add_argument('--output_directory', '-o', dest='output_directory', help='directory for output files', default='.mash')
    self.args = parser.parse_args()

    if not os.path.exists(self.args.output_directory):
      announce_file_out(self.args.output_directory) 
      os.makedirs(self.args.output_directory)

    self.original_directory = os.getcwd()

    announce_file_in(self.args.input_filename)
    text = open(self.args.input_filename, 'r').read()

    os.chdir(self.args.output_directory)
    self.mash_string(text)

  def mash_string(self, text):
    # Find the next open or close tag.
    # match = re.search(r"(\[\[\[)|(\]\]\])", text)


    stack = [ RootFrame() ]
      # A stack of the various frames we're parsing at the moment.
    
    while text:
      # Match an opening delimiter?
      match = re.search(r"^\[\[\[(.*)", text)
      if match:
        commands = match.group(1)
        text = text[len(match.group(0)):]

        # Is this a one-liner or a multi-liner?
        match = re.search(r"^(.*)\]\]\]", commands)
        if match:
          commands = match.group(1)
          Frame(commands).execute(self, stack[-1])
        else:
          stack.append(Frame(commands))
        continue
          

      # Match a closing delimiter?
      match = re.search(r"^\]\]\]", text)
      if match:
        completed_frame = stack.pop()
        completed_frame.execute(self, stack[-1])
        text = text[3:]
        continue
      
      # Not seeing opening or closing delimiters.  Grab as much ordinary text as
      # we can.  At least one character, until we see [ or ] again.
      match = re.search(r"^(.[^\[\]]*)", text, re.DOTALL)
      stack[-1].append_text(match.group(0))
      eaten = match.group(1)
      text = text[len(eaten):]


if __name__ == '__main__':
  Mash().engage()

  
