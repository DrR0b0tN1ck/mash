#!/usr/bin/env python

# Q. Why?
#
# A1. Allows me to avoid naming things that appear only quickly in passing.
#
# A2. Allows me to divide things into files based on content, rather that language.#
# A3. Can keep content and build instructions in the same place.


import argparse
import hashlib
import sys
import re
import os
import subprocess
import shutil
import glob

def announce_file_in(fname):
  print >>sys.stderr, "-->", fname

def announce_file_out(fname):
  print >>sys.stderr, "<--", fname

class Frame:
  def __init__(self, _commands, _text=""):
    # Keep the list of commands.
    self.commands = _commands 

    # Maybe start with some text.  We'll probably get more later from
    # append_text.
    self.text = _text

    # We may need to hash our text as a way of genreating unique but
    # predictable anonymous filenames.
    self.text_hash = None

    # Remember whether anything in this frame has changed.  This is an
    # attribute here, rather than a local variable below in execute() because
    # it might need to be set by a child frame.
    self.dirty = False

  def append_text(self, new_text):
    self.text += new_text

  def make_name(self, number):
    if self.text_hash is None:
      self.text_hash = hashlib.sha1(self.text + number).hexdigest()[:7]
    return self.text_hash + number

  def execute(self, mash, parent):
    print "[[[%s]]]" % self.commands

    # Replace things like $1 with anonymous names based on hashing the text.
    self.commands = re.sub(r'\$(\d+)', lambda m: self.make_name(m.group(1)), self.commands)

    # Loop through the commands we have.
    for command in self.commands.split(';'):
      command = command.strip()
      print " ", command

      # Commands that start with ! are "build" commands, which we should only
      # execute if we are a 'dirty' frame: If something has changed.
      match = re.search(r'^!(.*)', command)
      if match and self.dirty:
        # We need to build.  Drop the ! and continue normally.
        command = match.group(1)
      if match and not self.dirty:
        # No need to build.  Skip to the next thing.
        print "    (skipped)"
        continue

      # Save the text to a file.
      match = re.search(r"^save (.*)", command)
      if match:
        target = match.group(1)
        
        # Figure out if the file already exists with the same contents.
        try:
          f = open(target, 'r')
          existing_contents = f.read()
          f.close()
          exists_already = (existing_contents == self.text)
        except IOError:
          exists_already = False

        if not exists_already:
          announce_file_out(target)
          f = open(target, 'w')
          print >>f, self.text,
          f.close()
          self.dirty = True

        continue

      ### Append is disabled (for now?) because it does not play well with the
      ### dirty/build system --- there doesn't seem to be a good way to keep
      ### track of whether an appended file has really changed.
      ###
      ### Instead, it may work to write each separate nugget to an anonymous
      ### file with a certain extension, and then cat those file together in one
      ### step at the end.
      ###
      ### # Save the text to a file.
      ### match = re.search(r"^append (.*)", command)
      ### if match:
      ###   something_changed = True
      ###   target = match.group(1)
      ###   print "Appending to ", target
      ###   f = open(target, 'a')
      ###   print >>f, self.text
      ###   f.close()
      ###   continue
      
      # Print a literal into the parent frame.
      match = re.search(r"^print (.*)", command)
      if match:
        output = match.group(1)
        parent.append_text(output)
        continue
      
      # Read a file (or files) and append their contents to the text of this
      # frame.
      match = re.search(r"^read (.*)", command)
      if match:
        for filename in glob.glob(match.group(1)):
          print "reading", filename
          f = open(filename, 'r')
          self.append_text(f.read())
          f.close()
        continue


      # Execute a shell command.
      match = re.search(r"^exec (.*)", command)
      if match:
        shell_command = match.group(1)
        os.system(shell_command)
        continue

      # Keep a file, by copying it to the input directory.
      match = re.search(r"^keep (.*)", command)
      if match:
        file_to_keep = match.group(1)
        shutil.copy(file_to_keep, mash.original_directory)
        continue

      # Other commands that might make sense:
      # - read (append/replace the contents of a file to the text of the current frame)
      # - promote (append the text of the current frame to the text of the parent frame)
      
      # ?
      print command
      raise

    # All done executing commands.  Last step: If we're dirty, then our parent
    # should be dirty too.
    if self.dirty:
      parent.dirty = True
    
    # Done!
    return

  
  def __repr__(self):
    return "Frame(%s,%s)" % (self.commands.__repr__(), self.text.__repr__())

class RootFrame:
# Objects of this class act sufficiently like Frame objects to simplify the
# code below a bit, because they ensure that the stack is never empty, and that
# every real frame has a parent.
  def append_text(self, new_text):
    new_text = new_text.strip()
    if new_text:
      print "root-level text:", new_text


class Mash:
  def engage(self):
    # This is the 'main' function.
    parser = argparse.ArgumentParser()
    parser.add_argument(dest='input_filename', help='input filename')
    parser.add_argument('--debug', '-d', dest='debug', help='show debugging information', action='store_true')
    parser.add_argument('--output_directory', '-o', dest='output_directory', help='directory for output files', default='.mash')
    self.args = parser.parse_args()

    if not os.path.exists(self.args.output_directory):
      announce_file_out(self.args.output_directory) 
      os.makedirs(self.args.output_directory)

    self.original_directory = os.getcwd()

    announce_file_in(self.args.input_filename)
    text = open(self.args.input_filename, 'r').read()

    os.chdir(self.args.output_directory)
    self.mash_string(text)

  def mash_string(self, text):
    # A stack of the various frames we're parsing at the moment.
    stack = [ RootFrame() ]
    
    while text:
      # Match an opening delimiter?
      match = re.search(r"^\[\[\[(.*)", text)
      if match:
        commands = match.group(1)
        text = text[len(match.group(0)):]

        # Is this a one-liner or a multi-liner?
        match = re.search(r"^(.*)\]\]\]", commands)
        if match:
          commands = match.group(1)
          Frame(commands).execute(self, stack[-1])
        else:
          stack.append(Frame(commands))
        continue
          

      # Match a closing delimiter?
      match = re.search(r"^\]\]\]", text)
      if match:
        completed_frame = stack.pop()
        completed_frame.execute(self, stack[-1])
        text = text[3:]
        continue
      
      # Not seeing opening or closing delimiters.  Grab as much ordinary text as
      # we can.  At least one character, until we see [ or ] again.
      match = re.search(r"^(.[^\[\]]*)", text, re.DOTALL)
      stack[-1].append_text(match.group(0))
      eaten = match.group(1)
      text = text[len(eaten):]


if __name__ == '__main__':
  Mash().engage()

  
