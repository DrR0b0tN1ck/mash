#!/usr/bin/env python

# Q. Why?
#
# A1. Allows me to avoid naming things that appear only quickly in passing.
#
# A2. Allows me to divide things into files based on content, rather that language.#
# A3. Can keep content and build instructions in the same place.


import argparse
import hashlib
import sys
import re
import os
import subprocess
import shutil
import glob

def announce_file_in(fname):
  print >>sys.stderr, "-->", fname

def announce_file_out(fname):
  print >>sys.stderr, "<--", fname

class Frame:
  def __init__(self, _parent, _commands, _indent):
    # Remember our parent.
    self.parent = _parent

    # Keep the list of commands.
    self.commands = _commands 

    # How much indent do we have on the first line?  This will be removed from
    # each line before processing anything.  Important if the test is python
    # code.
    self.indent = _indent

    # Start with no text.  We'll probably get more later from
    # append_text.
    self.text = ""

    # We may need to hash our text as a way of genreating unique but
    # predictable anonymous filenames.
    self.text_hash = None

    # Remember whether anything in this frame has changed.  This is an
    # attribute here, rather than a local variable below in execute() because
    # it might need to be set by a child frame.
    self.dirty = False

    # Keep track of any macros that may be defined, in the form of a hash from
    # names to definitions.  Note that resolve_macro also looks up the chain of
    # parent frames, if it cannot find a definition at this level.
    self.macros = dict()

  def append_text(self, new_text):
    self.text += new_text

  def make_name(self, number):
    if self.text_hash is None:
      self.text_hash = hashlib.sha1(self.text + number).hexdigest()[:7]
    return self.text_hash + number

  def resolve_macro(self, name, args_list):
    if name in self.macros:
      commands = self.macros[name]
      commands = re.sub(r'#(\d+)', lambda m: args_list[int(m.group(1))-1], commands)
      return commands.split(';')

    else:
      # No definition for this macro at this level.  Maybe our parent knows it?
      return self.parent.resolve_macro(name, args_list)


  def execute(self, mash):
    print "[[[%s]]]" % self.commands

    # Are there any commands?  If not, ingore this frame.  Not sure why this
    # would happen except at the very top level.
    if not self.commands:
      return

    # Is this a macro definition?  These are special because they consme *all*
    # of the commands in the list.  The definition goes in the parent frame
    # (rather than this one), because this frame probably only has the macro
    # definition, and will be going away soon.
    match = re.search(r'def ([a-zA-Z0-9-]+): (.*)', self.commands)
    if match:
      name = match.group(1)
      definition = match.group(2)
      self.parent.macros[name] = definition
      return


    # Split the command list into individual commands.
    command_list = self.commands.split(';')
    
    # Loop through the commands we have.
    while command_list:
      command = command_list[0]
      command_list = command_list[1:]
      command = command.strip()

      # Replace things like $1 with anonymous names based on hashing the text.
      command = re.sub(r'\$(\d+)', lambda m: self.make_name(m.group(1)), command)
      print " ", command

      # Commands that start with ! are "build" commands, which we should only
      # execute if we are a 'dirty' frame: If something has changed.
      match = re.search(r'^!(.*)', command)
      if match and self.dirty:
        # We need to build.  Drop the ! and continue normally.
        command = match.group(1)
      if match and not self.dirty:
        # No need to build.  Skip to the next thing.
        print "    (skipped)"
        continue

      # Is it a macro to expand?
      match = re.search(r"^@([a-zA-Z0-9-]+)\((.*)\)", command)
      if match:
        macro_name = match.group(1)
        macro_args = match.group(2).split(',')
        command_list = self.resolve_macro(macro_name, macro_args) + command_list
        continue
      match = re.search(r"^@([a-zA-Z0-9]+)", command)
      if match:
        macro_name = match.group(1)
        macro_args = list()
        command_list = self.resolve_macro(macro_name, macro_args) + command_list
        continue

      # Save text to a file.
      match = re.search(r"^save (.*)", command)
      if match:
        target = match.group(1)
        
        # Figure out if the file already exists with the same contents.
        try:
          f = open(target, 'r')
          existing_contents = f.read()
          f.close()
          exists_already = (existing_contents == self.text)
        except IOError:
          exists_already = False

        if not exists_already:
          announce_file_out(target)
          f = open(target, 'w')
          print >>f, self.text,
          f.close()
          self.dirty = True
        else:
          print "    (no change)"

        continue

      ### Append is disabled (for now?) because it does not play well with the
      ### dirty/build system --- there doesn't seem to be a good way to keep
      ### track of whether an appended file has really changed.
      ###
      ### Instead, it may work to write each separate nugget to an anonymous
      ### file with a certain extension, and then cat those file together in one
      ### step at the end.  (Known issue: If things change, then the old versions
      ### are still around.)
      ###
      ###
      ### # Save the text to a file.
      ### match = re.search(r"^append (.*)", command)
      ### if match:
      ###   something_changed = True
      ###   target = match.group(1)
      ###   print "Appending to ", target
      ###   f = open(target, 'a')
      ###   print >>f, self.text
      ###   f.close()
      ###   continue
      
      # Print a literal into the parent frame.
      match = re.search(r"^print (.*)", command)
      if match:
        output = match.group(1)
        self.parent.append_text(output)
        continue
      
      # Read a file (or files) and append their contents to the text of this
      # frame.
      match = re.search(r"^read (.*)", command)
      if match:
        for filename in glob.glob(match.group(1)):
          print "    ", filename
          f = open(filename, 'r')
          self.append_text(f.read())
          f.close()
        continue

      # Execute a shell command, allowing its output to go to the terminal in
      # which mash is running, and without changing the text.
      match = re.search(r"^exec (.*)", command)
      if match:
        shell_command = match.group(1)
        os.system(shell_command)
        continue

      # Filter the text through a shell command.
      match = re.search(r"^filter (.*)", command)
      if match:
        shell_command = match.group(1)
        p = subprocess.Popen(shell_command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        self.text = p.communicate(input=self.text)[0]
        continue

      # Strip leading a trailing spaces.
      match = re.search(r"^strip", command)
      if match:
        self.text = self.text.strip()
        continue

      # Push our text up into the parent frame.
      match = re.search(r"^push", command)
      if match:
        self.parent.append_text(self.text)
        continue

      # Fix the indentation of the text.
      match = re.search(r"^unindent", command)
      if match:
        self.text = re.sub("\n\s{%d}" % self.indent, "\n", self.text)
        continue

      # Keep a file, by copying it to the input directory.
      match = re.search(r"^keep (.*)", command)
      if match:
        file_to_keep = match.group(1)
        shutil.copy(file_to_keep, mash.original_directory)
        continue

      # Other commands that might make sense:
      # - promote (append the text of the current frame to the text of the parent frame)
      
      # ?
      print command
      raise

    # All done executing commands.  Last step: If we're dirty, then our parent
    # should be dirty too.
    if self.dirty:
      self.parent.dirty = True
    
    # Done!
    return

  
  def __repr__(self):
    return "Frame(%s,%s)" % (self.commands.__repr__(), self.text.__repr__())


class Mash:
  def engage(self):
    # This is the 'main' function.
    parser = argparse.ArgumentParser()
    parser.add_argument(dest='input_filename', help='input filename')
    parser.add_argument('--debug', '-d', dest='debug', help='show debugging information', action='store_true')
    parser.add_argument('--output_directory', '-o', dest='output_directory', help='directory for output files', default='.mash')
    self.args = parser.parse_args()

    if not os.path.exists(self.args.output_directory):
      announce_file_out(self.args.output_directory) 
      os.makedirs(self.args.output_directory)

    self.original_directory = os.getcwd()

    announce_file_in(self.args.input_filename)
    text = open(self.args.input_filename, 'r').read()

    os.chdir(self.args.output_directory)
    self.mash_string(text)

  def mash_string(self, text):
    # The current frame for whatever we're parsing now.  This top one has no
    # parent.
    current_frame = Frame(None, "" , 0)
    
    while text:
      # Match an opening delimiter?
      match = re.search(r"^\[\[\[(.*)\n(\s*)", text)
      if match:
        commands = match.group(1)
        indent = match.group(2)
        text = text[len(match.group(0)):]

        # Is this a one-liner or a multi-liner?
        match = re.search(r"^(.*?)\]\]\](.*)", commands)
        if match:
          # One liner.
          commands = match.group(1)
          Frame(current_frame, commands, len(indent)).execute(self)
          text = match.group(2) + text
        else:
          current_frame = Frame(current_frame, commands, len(indent))
        continue
          

      # Match a closing delimiter?
      match = re.search(r"^\]\]\]", text)
      if match:
        current_frame.execute(self)
        current_frame = current_frame.parent
        text = text[3:]
        continue
      
      # Not seeing opening or closing delimiters.  Grab as much ordinary text as
      # we can.  At least one character, until we see [ or ] again.
      match = re.search(r"^(.[^\[\]]*)", text, re.DOTALL)
      current_frame.append_text(match.group(0))
      eaten = match.group(1)
      text = text[len(eaten):]


if __name__ == '__main__':
  Mash().engage()

  
