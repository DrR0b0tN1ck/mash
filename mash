#!/usr/bin/env python


import argparse
import sys
import re
import os
import subprocess

OUTPUT_DIR = 'mash_out'

def announce_file_in(fname):
  print >>sys.stderr, "-->", fname

def announce_file_out(fname):
  print >>sys.stderr, "<---", fname

class Frame:
  def __init__(self, _commands, _text=""):
    self.commands = _commands 
    self.text = _text

  def append_text(self, new_text):
    self.text += new_text

  def execute(self, parent):
    print "execute:"
    print "  self:", self
    print "  parent:", parent
    for command in self.commands.split(';'):
      command = command.strip()
      print "  command:", command

      # Save the text to a file.
      match = re.search(r"^save (.*)", command)
      if match:
        target = os.path.join(OUTPUT_DIR, match.group(1))
        print "Saving to ", target
        f = open(target, 'w')
        print >>f, self.text
        f.close()
        continue
      
      # Print a literal into the parent frame.
      match = re.search(r"^print (.*)", command)
      if match:
        output = match.group(1)
        parent.append_text(output)
        continue

      # Execute a command
      match = re.search(r"^exec (.*)", command)
      if match:
        shell_command = match.group(1)
        os.system(shell_command)
        continue
      
      # ?
      raise
  
  def __repr__(self):
    return "Frame(%s,%s)" % (self.commands.__repr__(), self.text.__repr__())

class RootFrame:
# Objects of this class act sufficiently like Frame objects to simplify the
# code below a bit, because they ensure that the stack is never empty, and that
# every real frame has a parent.
  def append_text(self, new_text):
    print "root-level text:", new_text

def mash_string(text):
  # Find the next open or close tag.
  # match = re.search(r"(\[\[\[)|(\]\]\])", text)


  stack = [ RootFrame() ]
    # A stack of the various frames we're parsing at the moment.
    # Each element is a pair:
    # - The command string
    # - The text itself.
  
  while text:
    # Match an opening delimiter?
    match = re.search(r"^\[\[\[(.*)", text)
    if match:
      commands = match.group(1)
      stack.append(Frame(commands))
      text = text[len(match.group(0)):]
      continue

    # Match a closing delimiter?
    match = re.search(r"^\]\]\]", text)
    if match:
      completed_frame = stack.pop()
      completed_frame.execute(stack[-1])
      text = text[3:]
      continue
    
    # Not seeing opening or closing delimiters.  Grab as much ordinary text as
    # we can.  At least one character, until we see [ or ] again.
    match = re.search(r"^(.[^\[\]]*)", text, re.DOTALL)
    stack[-1].append_text(match.group(0))
    eaten = match.group(1)
    text = text[len(eaten):]

  # for (doc, text) in docs.iteritems():
  #   if doc == top_level: continue
  #   print doc
  #   print text
  #   f = open(doc, 'w')
  #   print >>f, text
  #   f.close()

if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument(dest='input_filename', help='input filename')
  parser.add_argument('--debug', '-d', dest='debug', help='show debugging information', action='store_true')
  args = parser.parse_args()

  announce_file_in(args.input_filename)
  text = open(args.input_filename, 'r').read()
  mash_string(text)

  
